#pragma once

#ifndef _messages_H_
#define _messages_H_

#include "mcp_can.h"
#include "mcp_can_dfs.h"
#include "circular_buffer.h"

#include "stdlib.h"

//#define MAX_QUEUE 5
//#define SIZE 15



class periodic_message {

protected:

	// interval time for message in ms
	unsigned int interval_time_ms;

	// length of data in butes
	uint8_t data_length;

	// 29 or 11 bit identifier for extended or standard frames
	unsigned long identifier;

	// standard or extended frame
	bool extended;

	// true when data for the frame has been set correctly
	bool accepted;

	// used for counting period for messages
	unsigned long previous_time;

	// array that stores up to 8 byte message

	// bytes 0-3: identifier
	// Bytes 4-11:  message data
	// Byte 12: 3 LSB's: data length code. 
	INT8U databuf[SIZE];

	// CAN object pointer

	circular_buffer* bufferptr;

	INT8U* databuf_ptr;

	// Bytes 0-3:   identifier


	// Printing functions
	bool verbose;

	// pointer to upload FIFO queue
	//unsigned int time_array[100];
	//int counter;


public:

	// default constructor
	periodic_message(){}

	// constructor
	periodic_message(int input_interval_time)
	{
		interval_time_ms = input_interval_time;
		previous_time = 0;
		verbose = false;

		databuf_ptr = databuf;

	}

	// attach MCP_CAN object

	//periodic_message();
	void setInterval(int input_interval_time)
	{
		interval_time_ms = input_interval_time;
	}
	
	// sets length of data in the message
	void setDataLength(int input_data_length)
	{
		if (input_data_length > 8 || input_data_length < 0) {
			Serial.println("Incorrected data length");
			accepted = false;
		}
		else
			databuf[4] = input_data_length;
	}

	void setIdentifier(INT32U id, bool ext)
	{
		identifier = id;
		uint16_t canid;
		

		canid = (uint16_t)(id & 0x0FFFF);

		if (ext == 1)
		{
			// first 8 bits for extended message go into EID0, for extended identifier
			databuf[MCP_EID0] = (INT8U)(canid & 0xFF);
			// shifted 8 to the right for bit 7-15
			databuf[MCP_EID8] = (INT8U)(canid >> 8);
			// CAN ID reset for last 16 bits of identifier
			canid = (uint16_t)(id >> 16);
			// first 2 bits go into SIDL for EID16 and EID17, by masking them 
			databuf[MCP_SIDL] = (INT8U)(canid & 0x03);
			// last 3 bits added to high end of SIDL by masking and shifting 3 
			databuf[MCP_SIDL] += (INT8U)((canid & 0x1C) << 3);
			// sets extended ID in bit 3 of SIDL
			databuf[MCP_SIDL] |= MCP_TXB_EXIDE_M;
			// final 8 bits of CAN ID filled into SIDH
			databuf[MCP_SIDH] = (INT8U)(canid >> 5);
			// sets extended bool to true if identifier is in extended format
			extended = true;
		}
		else
		{
			// shifts 3 to the right for the 3 MSB's
			databuf[MCP_SIDH] = (INT8U)(canid >> 3);
			// shifts 5 to the left as 5 MBS's in SIDL are the first 5 bytes of ID
			databuf[MCP_SIDL] = (INT8U)((canid & 0x07) << 5);
			// these are the extended identifier bits, which will be 0 for standard ID
			databuf[MCP_EID0] = 0;
			databuf[MCP_EID8] = 0;
		}
	}

	void setExtended(boolean input_extended)
	{
		extended = input_extended;
	}


	unsigned int getInterval()
	{
		return interval_time_ms;
	}

	void setVerbose(bool input_verbose)
	{
		verbose = input_verbose;
	}
	void setMessage(int length, INT8U* buf)
	{
		setDataLength(length);
		if(verbose)
			Serial.println("Setting message:");
		
		for (int i = 0; i < length; i++)
		{
			if (verbose)
			{
				Serial.print(buf[i]);
				Serial.print(" ");
				if (i == 7)
					Serial.println("");
			}
			
			// assigns message to data buffer
			databuf[i+5] = buf[i];

			//Serial.print("printing message buffer ");
			//Serial.print(msg[i]);
			//Serial.print(" ");
		}
	}

	void printData()
	{
		Serial.println("Printing message data (messages: printData)");
		for (int i = 0; i < SIZE; i++)
		{
			Serial.print(databuf[i], HEX);
			Serial.print(" ");
		}
		Serial.println("");
	}

	void attachBufferPointer(circular_buffer* ptr_in)
	{
		bufferptr = ptr_in;
	}

	void printMessage()
	{
		Serial.println("Message data: ");
		for (int i = 5; i < data_length+5; i++)
		{
			Serial.print(databuf[i]);
			Serial.print(" ");
		}
		Serial.println("");
	}

	void printIdentifier()
	{
		Serial.print("Identifier: ");
		Serial.println(identifier, HEX);
	}
	
	// running functions

	// checks time has elapsed
	void runMessage()
	{
		//Serial.println("run message");
		if (hasTimeElapsed())
		{
			bufferptr->enqueue(databuf_ptr);
		}
	}



	bool hasTimeElapsed()
	{
		unsigned long current_time = millis();

		if (current_time - previous_time > interval_time_ms) {
			previous_time = current_time;
			return true;
		}
		else
			return false;
	}

};

class poisson_message: public periodic_message {

protected:

	//
	double rateparameter_ms;

	// time until next message generated by function nextMessage();
	unsigned int next_message_ms;

	// waits until next message has been sent, to generate a new time
	bool time_elapsed;

	// used for counting period for messages
	unsigned long previous_time;

	// function should not be used by sketch
	bool hasTimeElapsed()
	{
		unsigned long current_time = micros();
		if (current_time - previous_time > next_message_ms) {
			previous_time = current_time;
			generateNextMessageTime();
			time_elapsed = true;
			return true;
		}
		else
			return false;
	}

	bool hasTimeElapsed_2()
	{
		unsigned long current_time = micros();
		if (current_time - previous_time > next_message_ms) {
			previous_time = current_time;
			generateNextMessageTime();
			time_elapsed = true;
			return true;
		}
		else
			return false;
	}

	//float probability_array[100];
	//unsigned int time_array[100];
	//int counter = 0;

public:
	poisson_message(){
		databuf_ptr = databuf;

	}

	void seed()
	{
		int time = millis();
		srand(time);
	}

	// constructor
	poisson_message(int input_messageFreq)
	{
		setFrequency(input_messageFreq);
		databuf_ptr = databuf;
	}
	// Set how many ms on average a message for poisson distribution to be generated
	void setFrequency(int input_messageFreq)
	{
		rateparameter_ms = (float)1/input_messageFreq;
	}

	unsigned int generateNextMessageTime()
	{
		// why does it stop if this is left out
		//Serial.println("GEnerating message");
		float random = ((float)rand() / (RAND_MAX));

		//Serial.print("divided random value: ");
		//Serial.println(random);


	/*	probability_array[counter] = random;*/

		random = -logf(1 - random);

		//Serial.print("logged value: ");
		//Serial.println(random);

		next_message_ms = random / rateparameter_ms;

		//time_array[counter] = next_message_ms;

		//next_message_ms = (unsigned int)-(logf(1.0f - (float)(rand() / (RAND_MAX + 1))) / rateparameter_ms);
	
		//if (counter == MAX_ARRAY)
		//{
		//	for (int i = 0; i < MAX_ARRAY; i++)
		//	{
		//		Serial.println(time_array[i]);
		//	}
		//}
		//counter++;
		//Serial.println(counter);

		//Serial.print("next message time generated: ");
		//Serial.println(next_message_ms);


		 //Serial.print("total time: ");
		 //Serial.println(messagetime_total);
		 //Serial.print("Counter: ");
		 //Serial.println(avetime_counter);
		 //Serial.print("average time between messages: ");
		 //Serial.println(messagetime_total / avetime_counter);
		 //Serial.println("");

	}



	void runMessageGenerator()
	{
		//Serial.println("running message ");
		//delayMicroseconds(100);
		if (hasTimeElapsed())
		{
			bufferptr->enqueue(databuf_ptr);
		}
	}

	void runMessage_dropFront()
	{
		if (hasTimeElapsed())
		{
			bufferptr->enqueue_dropFront(databuf_ptr);
		}
	}
};

#endif
